# Testwork **Fanbox**
[![Build Status](https://travis-ci.org/Rattt/find_max.svg?branch=master)](https://travis-ci.org/Rattt/find_max) 
**FindMax** 
## Задание:
> <https://dl.fun-box.ru/qt-ruby.pdf> 

## Level 1

1. Если лямбда вызывается с большим, или меньшим количеством аргументов, чем необходимо, тогда `Ruby` выдает ошибку `ArgumentError`.
Когда лямбда-функция возвращает значение и эта лямбда вызывается внутри метода, то метод будет просто продолжать свое выполнение после окончания работы лямбды, 
пока в конце-концов он сам не вернет свое собственное значение. 
Однако, когда Proc возвращает значение и эта процедура вызывается внутри метода, тогда выполнение этого метода будет остановлено.

2. Операция имеет больший приоритет `&&` чем `and`.

3. (
### Достоинтства:
* Относится к языкам программирования сверхвысокого уровня `VHLL`, то есть обладает высоким уровнем абстракции и предметным подходом в реализации алгоритмов.
* Реализует концептуально чистую объектно-ориентированную парадигму (Все операции выделины в классы).
* Большой набор готовых решений `gem`.
* Возможности языка можно расширить при помощи библиотек, написанных на `C` или `Ruby`.
* Удобный синтаксис.
* Метапрограммирование.
### Недостатки:
* Проигрывает по производительности с `Node.js`, `Java`, `Go`, `Elexir`.
* До выхода `Ruby` 2.0 `private` и `protected` вообще ничем не отличались.
* Отсутствие абстрактных классов.
* Часто самым простым способом выполнить одновременно две вещи является использование потоков в `Ruby`. 
  Они являются внутрипроцессными, встроенными в интерпретатор `Ruby`. 
  Это делает потоки `Ruby` полностью переносимыми, т.е. независимыми от операционной системы. 
  Но в то же время вы точно не получите выгоду от использования родных, нативных потоков.

4. `Ruby on Rails` хорошо подходит для быстро растущих проектов.
   Поэтому часто используется в стартапах.
   Успех этому фреймворку обеспечила стандартизация, превалирование соглашений
   над конфигурацией. Принцип `DRY`. И возможность как создавать очень быстро
   новые части приложения (большой набор генераторов) так и тестировать их. 
   Что в будущем экономит много времени используя `MVC` архетектуру.
   Вцелом фремворк хорошо подходит для `CRUD` приложений.
   Этому способствует: `gem`s, поддержка большинства `DBMS` через `Active
   Records`  и прочие `ORM`. 
   Включен новый режим `Api`. 
  `Api` режим нужен нетолько для построения `Api`, но и созданию модных `SPA` приложений.
   Где `Rails` выступает как источник данных, для фронт части.
   ### Альтернативы
   * Традиционно для создания `Api` использовались микро фреймворки `Grape`, `Sinatra`.
   * Для создания группы зависимых проектов (экосистемы) используется `Hanami`(`Lotus`)
   * `Trailblaizer` выделяет логику в операции и создает `cell` как альтернатива `helpers` которые не находятся в
     глобальной области видимости. В целом интересный подход но не зрелый, как мне
     кажется. 

5. Проверить доступную память. 
   Вести лог, чтобы выявить замыкания.
   Запустить скрипт с максимально возможными предупреждениями -W[level=2]
   Запустить трассировку и включить предупреждения по максимому```ruby  ruby -w -W2 -r tracer xxx.rb ```
   Попробовать начать трасcировать его с `byebug`.

6. Потери памяти можно выделить на пиковые и растущие.
   Пиковые как правило более выражены и являются недостатками алгоритма и применяемых методов.
   К ним можно отнести чтение больших файлов в память, десерилизация и серелизация больших обьемов данных.

   Растущие же потери данных могут указывать на 2 вещи:
   
* Ошибки в С библиотеках, что реже
  Вызваны работой с указателями, необходимость С работать с памятью.

* Зависание обьектов в памяти из-за сохранившейся сылки на него и невозможностью очистки его `Garbage
  Collector`ом.  Oбъекты хранятся в так называемой куче и пока есть сылки на обьект Garbage
  Collector не может его уничтожить и освободить память.

  Чтобы понять с какой проблемой мы столкнулись необходимо собрать статистику и построить график.
  Так-же надо учитывать, что сбор статистики замедлет работу системы.

  `Graphite` , `statsd` и `Grafana` для вычисления метрик приложения.
  Показателем будет `RSS`

  Иснтрументы пригодные для поска проблем с памятью:
* `monit`
* `inspector` 
* `unicorn worker killer`
* `valgrind` – для поиска утечек в самом ruby и экстеншнах.
* `bleak_house` – инструмент для отслеживания аллокейшнов ruby-объектов. Подходит для `Rails`.
  `Ruby 2.1` предоставляет сброс кучи.
* `get_process_mem` — удобный способ получить информацию о памяти, используемой текущим `Ruby-процессом.
* `memory_profiler` В качестве профилировщика можно использовать также `ruby-prof`
* `derailed_benchmarks` для мониторинга имеющий некоторые замечательные возможности, характерные для `Rails`.

  После выявления проблемных мест, приступаем к лечению.  
  Решение проблемы:
* Начиная с `Ruby 2.0` появилась замечательная возможность делать ленивые перечислители (lazy enumerator). 
  Это позволяет сильно уменьшить потребление памяти при вызове цепочки методов перечислителя. 
* Читать файлы построчно
* Использовать потоковые серилизаторы и десерелизаторы
* Неиспользовать больших массивов.
* Удалять сылки на обьект после его использования. 
  К примеру массовая генерация Символов может серьезно отразится на памяти, так как они будут в ней висеть. 

7. Стандартное использование `JRuby` — это его встраивание в `Java`-приложение для
   поддержки скриптинга и ускорения разработки, что является преимуществом языка
   Ruby перед статическими языками. Также может использоваться для запуска
   `Rails`-приложений на `Java`-платформах.
   `JVM` оптимизируется под поступающие запросы и после прогрева работает быстро.
   `JRuby` таким образом может использовать плюсы `JVM`.
   Однако подобные гибриды имеют небольшие несовместимости, которые надо
   учитывать.

8. `Active Record` достоинства и недостатки(

### AR Достоинства:

* Первое. Объектно‐ориентированный подход.
При использовании `Active Record` не нужно вносить в бизнес‐логику куски `SQL` запросов, с `Active Record` можно оперировать только объектами.

* Реализации `Active Record` могут работать через различные драйверы для доступа к `DBMS`, а также генерировать специфичные для конкретной `DBMS` запросы, 
  вынося все это с уровня бизнес‐логики. И в данном случае, программисту необходимо только описать что он хочет, а не описывать то, как он хочет.

* Валидация, реализуется механизмы для валидации значений полей. 

* Сохранение происходит в одном месте, что позволяет легко изучить, как это работает.

* `Active Record` поддерживают связи

* Писать код с `Active Record` получается быстро и легко, в том случае, когда свойства объекта прямо соотносятся с колонками в базе данных.

* Active Record дает полный стек средств для работы с базой, что ускоряет
  разработку.

### AR Недостатки:

* Модели `Active Record` нарушаю принципы `SOLID`. 
В частности, принцип единой ответственности (`SRP` — «S» в принципах `SOLID`).
Согласно принципу, доменный объект должен иметь только одну зону ответственности, 
то есть только свою бизнес-логику. Вызывая его для сохранения данных, вы добавляете ему дополнительную зону ответственности, 
увеличивая сложность объекта, что усложняет его поддержку.

* `Active Record` требует значительного количества кода, который затем приводит к большому объему памяти, 
используемому для разворачивания экземпляра. Cоздав достаточное количество экземпляров `Active Record`,
которые не собираются сборщиком мусора достаточно быстро, то доступная память может быть полностью использована.

* Экземпляры `Active Record` делают много: валидация, генерация запросов, логика домена и многое другое. 
Да, это упрощает и, возможно, делает код более читаемым, но добавляет сложность, по крайней мере, в фоновом режиме.
Если когда-либо столкнутся с новой глубокой ошибкой `Active Record`, то придется потратить много времени.

* `Active Record` не эффективно генерирует `Sql`.
Это не вина `Active Record`, у `ORM` свои ограничения. 
Для простых запросов он работает нормально.
Хотя по мере того, как запросы становятся более сложными, тем хуже, что `SQL` будет генерировать `Active Record`. 
Просто `ORM` не может создать оптимизированный сложный запрос лучше, чем опытный инженер.

* Чтобы запустить тесты `rspec`, мне придется загружать `Rails`.
Тестировать `Active Record` сложнее из-за нескольких зон ответственности.

### OHM Достоинство:
Использует hash и списки Redis, для эмуляции реляцционых таблиц и их связей.
Используя преимущества производительности Redis, получаем довольно интересную
штуку.

### OHM Недостатки:
* Redis подходит не для всех данных.
* Недостаточная поддержка библеотеки, имеются баги, которые устраняются.
* Привязка к конкретной `DBMS`

### DataMapper Достоинство:
* ORM, который является быстрой, потокобезопасной и многофункциональной.
* Data Mapper — это программная прослойка, разделяющая объект и DBMS. 
  Его обязанность — пересылать данные между ними и изолировать их друг от друга. 
  При использовании Data Mapper'а объекты не нуждаются в знании о существовании DBMS. 
  Они не нуждаются в SQL-коде, и (естественно) в информации о структуре DBMS. 
  Так как Data Mapper - это разновидность паттерна Mapper, сам объект-Mapper неизвестен объекту.

### DataMapper Недостатки:
* Разработка этой библеотеки кажется остановилась, повлияла на создание `ROM`
  проекта.

### ROM Достоинство:
* Изолировать приложение от сохранения данных.
* Предоставить минимум инфраструктуры для отображения и сохранения.
* Предоставление общих абстракций для компонентов нижнего уровня.
* Обеспечить возможность использовать мощных возможностей DBMS

### ROM Недостатки
* Небольшое сообщество которое его поддерживает.

### Sequel Достоинство:
* Sequel обеспечивает безопасность потоков, объединение пулов и краткую DSL для построения SQL-запросов и схем таблиц.
* Sequel включает в себя комплексный уровень ORM для сопоставления записей с объектами Ruby и обработки связанных записей.
* Sequel поддерживает расширенные функции базы данных, такие как подготовленные операторы, связанные переменные, точки сохранения, двухфазное комментирование,
  изоляция транзакций, конфигурации главного / подчиненного устройства и разбиение базы данных.
* В Sequel в настоящее время есть адаптеры для `ADO`, `Amalgalite`, `IBM_DB`, `JDBC`, `MySQL`, `Mysql2`, `ODBC`, `Oracle`, `PostgreSQL`, `SQLAnywhere`, `SQLite3` и `TinyTDS`.
* `Hanami model` и `Rom` используют его.
### Sequel Недостатки
* Недостаточная поддержка в Rails сообществе.

### Известные мне ORM
 `Active Records`, `OHM`, `DataMapper`, `ROM`, `Sequel`

### Выводы:
Большая разница между стилем `Active Record` и стилем `Data Mapper` заключается в том, 
что стиль `Data Mapper` полностью отделяет ваш домен от уровня сохранения. 
Это означает, что ни один из объектов вашей модели ничего не знает о базе данных.
Если есть возможность проектировать базу данных в соответствии с конвенциями `Rails` - используя `Active Record`. Я сэкономлю много сил и средств.
Если я строю проект над готовой базой или если структура проектируемой DBMS слишком сложна - использую `Sequel`, 
делая преобразователи данных, строя абстрактную, отвязанную от DBMS объектную модель.
