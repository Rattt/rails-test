
# Testwork **Fanbox**
[![Build Status](https://travis-ci.org/Rattt/find_max.svg?branch=master)](https://travis-ci.org/Rattt/find_max) 
**FindMax** 
## Задание:
> <https://dl.fun-box.ru/qt-ruby.pdf> 

## Level 1

1. Если лямбда вызывается с большим, или меньшим количеством аргументов, чем необходимо, тогда Ruby выдает ошибку ArgumentError.
Когда лямбда-функция возвращает значение и эта лямбда вызывается внутри метода, то метод будет просто продолжать свое выполнение после окончания работы лямбды, 
пока в конце-концов он сам не сам не вернет свое собственное значение. 
Однако, когда Proc возвращает значение и эта процедура вызывается внутри метода, тогда выполнение этого метода будет остановлено.


2. Операция имеет больший приоритет `&&` чем `and`.
3. (
### Достоинтства:
* Относится к языкам программирования сверхвысокого уровня `VHLL`, то есть обладает высоким уровнем абстракции и предметным подходом в реализации алгоритмов;
* Реализует концептуально чистую объектно-ориентированную парадигму (Все операции выделины в классы)
* Большой набор готовых решений 'gem'
* Возможности языка можно расширить при помощи библиотек, написанных на C или Ruby;
* Удобный синтаксис
* Метопрограмирование
### Недостатки:
* Проигрует по производительности с `Node.js`, `Java`, `Go`, `Elexir`.
* До выхода Ruby 2.0 `private` и `protected` вообще ничем не отличались.
* Отсутствие абстрактных классов.
* Часто самым простым способом выполнить одновременно две вещи является использование потоков в Ruby. 
  Они являются внутрипроцессными, встроенными в интерпретатор Ruby. 
  Это делает потоки Ruby полностью переносимыми, т.е. независимыми от операционной системы. 
  Но в то же время вы точно не получите выгоду от использования родных, нативных потоков.

4. `Ruby on Rails` хорошо подходит для быстро растуших проектов.
   Этому способствует: `gem`s, поддержка большинства база данных через `Active
   Records`  и прочие `ORM`. Включен режим `Api`. И инфраструктура из коробки.
  `Api` режим нужен нетолько для построения `Api`, но и созданию `SPA` приложений.
   Где `Rails` выступает как источник данных, для фронт части.
   ### Альтернативы
   * Традиционно для создания `Api` использовались микро фреймворки `Grape`, `Sinatra`.
   * Для создания группы зависимых проектов (экосистемы) используется `Hanami`(Lotus)
   * `Trailblaizer` выделяет логику в операции и создает `cell` которые не находятся в
     глобальной области видидимости. В целом интересный подход но не зрелый, как мне
     кажется. 
5. Проверить доступную память. Вести лог, чтобы выявить замыкания.
   Попробвать начать трасировать его с `byebug`
Или запустить скрипт таким образом ```ruby  ruby -r tracer xxx.rb ```
6. Oбьекты хранятся в так называемой куче и пока есть сылки на обьект Garbage
   Collector не может его уничтожить и освободить память.
   В помощь нам приходят: `monit`, `inspector`, `unicorn worker killer`
   Но первое что мы должны сделать - это составить график потребления памяти.
   Graphite , statsd и Grafana для вычисления метрик приложения.
   Показателем будет RSS
   Можем также встроить мониторинг:
   ```ruby 
   require 'objspace'
   ObjectSpace.trace_object_allocations_start
   ```
   valgrind – для поиска утечек в самом ruby и экстеншнах.
   bleak_house – инструмент для отслеживания аллокейшнов ruby-объектов. Подходит для Rails.
   Ruby 2.1 предоставляет сброс кучи.

7. Стандартное использование JRuby — это его встраивание в Java-приложение для
   поддержки скриптинга и ускорения разработки, что является преимуществом языка
   Ruby перед статическими языками. Также может использоваться для запуска
   Rails-приложений на Java-платформах.
   JVM оптимизируется под поступающие запросы и после прогрева работает быстро.
   JRuby таким образом может использовать плюсы JVM
   Однако подобные гибриды имеют небольшие несовместимости, которые надо
   учитывать.

