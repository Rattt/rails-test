# Testwork **Fanbox**
[![Build Status](https://travis-ci.org/Rattt/find_max.svg?branch=master)](https://travis-ci.org/Rattt/find_max) 
**FindMax** 
## Задание:
> <https://dl.fun-box.ru/qt-ruby.pdf> 

## Level 1

1. Если лямбда вызывается с большим, или меньшим количеством аргументов, чем необходимо, тогда `Ruby` выдает ошибку `ArgumentError`.
Когда лямбда-функция возвращает значение и эта лямбда вызывается внутри метода, то метод будет просто продолжать свое выполнение после окончания работы лямбды, 
пока в конце-концов он сам не вернет свое собственное значение. 
Однако, когда Proc возвращает значение и эта процедура вызывается внутри метода, тогда выполнение этого метода будет остановлено.

2. Операция имеет больший приоритет `&&` чем `and`.

3. (
### Достоинтства:
* Относится к языкам программирования сверхвысокого уровня `VHLL`, то есть обладает высоким уровнем абстракции и предметным подходом в реализации алгоритмов.
* Реализует концептуально чистую объектно-ориентированную парадигму (Все операции выделины в классы).
* Большой набор готовых решений `gem`.
* Возможности языка можно расширить при помощи библиотек, написанных на `C` или `Ruby`.
* Удобный синтаксис.
* Метопрограмирование.
### Недостатки:
* Проигрует по производительности с `Node.js`, `Java`, `Go`, `Elexir`.
* До выхода Ruby 2.0 `private` и `protected` вообще ничем не отличались.
* Отсутствие абстрактных классов.
* Часто самым простым способом выполнить одновременно две вещи является использование потоков в `Ruby`. 
  Они являются внутрипроцессными, встроенными в интерпретатор `Ruby`. 
  Это делает потоки `Ruby` полностью переносимыми, т.е. независимыми от операционной системы. 
  Но в то же время вы точно не получите выгоду от использования родных, нативных потоков.

4. `Ruby on Rails` хорошо подходит для быстро растуших проектов.
   Поэтому часто используется в стартапах.
   Успех этому фреймворку обеспечила стандартизация, привалирование соглашений
   над конфигурацией. Принцип `DRY`. И возможность как создавать очень быстро
   новые части приложения (большой набор генераторов) так и тестировать их. 
   Что в будущем экономит много времени используя `MVC` архетектуру.
   Вцелом фремворк хорошо подходит для `CRUD` приложений.
   Этому способствует: `gem`s, поддержка большинства DBMS через `Active
   Records`  и прочие `ORM`. 
   Включен новый режим `Api`. 
  `Api` режим нужен нетолько для построения `Api`, но и созданию модных `SPA` приложений.
   Где `Rails` выступает как источник данных, для фронт части.
   ### Альтернативы
   * Традиционно для создания `Api` использовались микро фреймворки `Grape`, `Sinatra`.
   * Для создания группы зависимых проектов (экосистемы) используется `Hanami`(`Lotus`)
   * `Trailblaizer` выделяет логику в операции и создает `cell` которые не находятся в
     глобальной области видидимости. В целом интересный подход но не зрелый, как мне
     кажется. 

5. Проверить доступную память. Вести лог, чтобы выявить замыкания.
   Попробвать начать трасировать его с `byebug`.
   Или запустить скрипт таким образом ```ruby  ruby -r tracer xxx.rb ```

6. Oбьекты хранятся в так называемой куче и пока есть сылки на обьект Garbage
   Collector не может его уничтожить и освободить память.
   В помощь нам приходят: `monit`, `inspector`, `unicorn worker killer`
   Но первое что мы должны сделать - это составить график потребления памяти.
   `Graphite` , `statsd` и `Grafana` для вычисления метрик приложения.
   Показателем будет `RSS`
   Можем также встроить мониторинг:
   ```ruby 
   require 'objspace'
   ObjectSpace.trace_object_allocations_start
   ```
   Это позволит узнать нам какие обьекты являются проблемными.
   valgrind – для поиска утечек в самом ruby и экстеншнах.
   bleak_house – инструмент для отслеживания аллокейшнов ruby-объектов. Подходит для Rails.
   `Ruby 2.1` предоставляет сброс кучи.

7. Стандартное использование `JRuby` — это его встраивание в `Java`-приложение для
   поддержки скриптинга и ускорения разработки, что является преимуществом языка
   Ruby перед статическими языками. Также может использоваться для запуска
   `Rails`-приложений на `Java`-платформах.
   `JVM` оптимизируется под поступающие запросы и после прогрева работает быстро.
   `JRuby` таким образом может использовать плюсы `JVM`.
   Однако подобные гибриды имеют небольшие несовместимости, которые надо
   учитывать.

8. `Active Record` достоинства и недостатки(

### AR Достноинства:

* Первое. Объектно‐ориентированный подход.
При использовании `Active Record` не нужно вносить в бизнес‐логику куски `SQL` запросов, с `Active Record` можно оперировать только объектами.

* Реализации `Active Record` могут работать через различные драйверы для доступа к `DBMS`, а также генерировать специфичные для конкретной `DBMS` запросы, 
  вынося все это с уровня бизнес‐логики. И в данном случае, программисту необходимо только описать что он хочет, а не описывать то, как он хочет.

* Валидация, реализуется механизмы для валидации значений полей. 

* Сохранение происходит в одном месте, что позволяет легко изучить, как это работает.

* `Active Record` поддерживают связи

* Писать код с `Active Record` получается быстро и легко, в том случае, когда свойства объекта прямо соотносятся с колонками в базе данных.

* Active Record дает полный стек средств для работы с базой, что ускоряет
  разработку.

### AR Недостатки:

* Модели `Active Record` нарушаю принципы `SOLID`. 
В частности, принцип единой ответственности (`SRP` — «S» в принципах `SOLID`).
Согласно принципу, доменный объект должен иметь только одну зону ответственности, 
то есть только свою бизнес-логику. Вызывая его для сохранения данных, вы добавляете ему дополнительную зону ответственности, 
увеличивая сложность объекта, что усложняет его поддержку.

* `Active Record` требует значительного количества кода, который затем приводит к большому объему памяти, 
используемому для разворачивания экземпляра. Cоздав достаточное количество экземпляров `Active Record`,
которые не собираются сборщиком мусора достаточно быстро, то доступная память может быть полностью использована.

* Экземпляры `Active Record` делают много: валидация, генерация запросов, логика домена и многое другое. 
Да, это упрощает и, возможно, делает код более читаемым, но добавляет сложность, по крайней мере, в фоновом режиме.
Если когда-либо столкнутся с новой глубокой ошибкой `Active Record`, то придется потратить много времени.

* `Active Record` не эфективно генерирует `Sql`.
Это не вина `Active Record`, у `ORM` свои ограничения. 
Для простых запросов он работает нормально.
Хотя по мере того, как запросы становятся более сложными, тем хуже, что `SQL` будет генерировать `Active Record`. 
Просто `ORM` не может создать оптимизированный сложный запрос лучше, чем опытный инженер.

* Чтобы запустить тесты `rspec`, мне придется загружать `Rails`.
Тестировать `Active Record` сложнее из-за нескольких зон ответственности.

### OHM Достоинства
Использует hash и списки Redis, для эмуляции реляционых таблиц и их связей.
Используя приимущества производительности Redis, получаем довольно интересную
штуку.

### OHM Недостатки
* Redis подходит не для всех данных.
* Недостаточная поддержка библиотеки, имеются баги, которые устраняются.
* Привязка к конкретной `DBMS`

### DataMapper Достоинства
* ORM, который является быстрой, потокобезопасной и многофункциональной.
* Data Mapper — это программная прослойка, разделяющая объект и DBMS. 
  Его обязанность — пересылать данные между ними и изолировать их друг от друга. 
  При использовании Data Mapper'а объекты не нуждаются в знании о существовании DBMS. 
  Они не нуждаются в SQL-коде, и (естественно) в информации о структуре DBMS. 
  Так как Data Mapper - это разновидность паттерна Mapper, сам объект-Mapper неизвестен объекту.

### DataMapper Недостатки
* Разработка этой библеотеки кажется остановилась, повлияла на созднаие `ROM`
  проекта.

### ROM Достоинства
* Изолировать приложение от сохранения данных.
* Предоставить минимум инфраструктуры для отображения и сохранения.
* Предоставление общих абстракций для компонентов нижнего уровня.
* Обеспечить возможность использовать мощьных возможностей DBMS
### ROM Недостатки
* Небольшое сообщество которое его поддерживает.

### Sequel Достоинства
* Sequel обеспечивает безопасность потоков, объединение пулов и краткую DSL для построения SQL-запросов и схем таблиц.
* Sequel включает в себя комплексный уровень ORM для сопоставления записей с объектами Ruby и обработки связанных записей.
* Sequel поддерживает расширенные функции базы данных, такие как подготовленные операторы, связанные переменные, точки сохранения, двухфазное комментирование,
  изоляция транзакций, конфигурации главного / подчиненного устройства и разбиение базы данных.
* В Sequel в настоящее время есть адаптеры для `ADO`, `Amalgalite`, `IBM_DB`, `JDBC`, `MySQL`, `Mysql2`, `ODBC`, `Oracle`, `PostgreSQL`, `SQLAnywhere`, `SQLite3` и `TinyTDS`.
* `Hanami model` и `Rom` используют его.
### Sequel Недостатки
* Недостаточная поддержка в Rails сообществе.

### Известные мне ORM
 `Active Records`, `OHM`, `DataMapper`, `ROM`, `Sequel`

### Выводы:
Большая разница между стилем `Active Record` и стилем `Data Mapper` заключается в том, 
что стиль `Data Mapper` полностью отделяет ваш домен от уровня сохранения. 
Это означает, что ни один из объектов вашей модели ничего не знает о базе данных.
Если есть возможность проектировать базу данных в соответствии с конвенциями `Rails` - используя `Active Record`. Я сэкономлю много сил и средств.
Если я строю проект над готовой базой или если структура проектируемой DBMS слишком сложна - использую `Sequel`, 
делая преобразователи данных, строя абстрактную, отвязанную от DBMS объектную модель.

